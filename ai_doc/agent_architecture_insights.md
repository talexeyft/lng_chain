# Архитектурные дилеммы AI-агентов: Как не утонуть в контексте

Здесь собраны ключевые инсайты по проектированию сложных агентных систем. Это не просто "best practices", а кровью (и токенами) написанные правила выживания LLM в больших проектах.

---

## 1. Дилемма "Руки или Мозги": Tool vs Skill
**Интрига:** У нас есть функция `fetch_url`. Стоит ли оборачивать её в отдельный Скилл, чтобы придать ей значимости?

**Вердикт:** **Оставить Тулом (Tool).**

**Почему именно так:**
Скилл — это мыслительный процесс, инструкция, стратегия («Как искать»). Тул — это атомарное действие, «руки» агента («Взять»).
Если упаковать простой `request.get` в Скилл, мы заставим модель загружать лишний контекст ради примитивного действия. Это как собирать совещание директоров, чтобы закрутить одну лампочку. Тулы должны быть легкими и переиспользуемыми разными Скиллами.

---

## 2. Кошмар 100 API: Проблема "Шведского стола"
**Интрига:** Биллинг имеет 100 эндпоинтов. Если дать их все агенту, он сойдет с ума или начнет галлюцинировать. Как быть?

**Вердикт:** **Паттерн "Фасад" или Группировка.**

**Почему именно так:**
Attention (внимание) модели ограничено. Когда в списке инструментов 100 функций, они размывают фокус.
*   **Фасад:** Делаем один тул `manage_billing(action, params)`, где `action` — это строка ('check_balance', 'refund'). Модель выбирает *тип действия*, а код маршрутизирует.
*   **Группировка:** Разбиваем на пакеты (`BillingInfo`, `BillingActions`). Модель видит только нужный пакет в нужный момент.

---

## 3. Иерархия Власти: Проблема Тысячи Инструкций
**Интрига:** В контакт-центре 1000 регламентов. Загрузить их все в промпт — значит убить контекстное окно и разориться.

**Вердикт:** **Иерархия Скиллов (Supervisor Pattern).**

**Почему именно так:**
Мы строим корпорацию.
1.  **Level 1 (Router):** Главный агент знает только отделы (Техподдержка, Биллинг, Продажи).
2.  **Level 2 (Supervisor):** Агент Биллинга знает только свои темы (Возвраты, Счета).
3.  **Level 3 (Worker):** Конечный агент решает задачу.
Изоляция контекста — наше всё. Агент техподдержки физически не должен знать, как делать возврат денег. Это безопасно и эффективно.

---

## 4. Секреты Progressive Disclosure: Исчезающий контекст
**Интрига:** Как агент может знать 1000 навыков, но использовать их мгновенно, не перегружая память?

**Вердикт:** **Динамическая инъекция (Injection).**

**Почему именно так:**
Агент не "помнит" все скиллы. Он видит только их "обложки" (description).
Как только он выбирает `BillingSkill`, содержимое этого скилла (инструкции + инструменты) жестко внедряется в системный промпт. Как только задача решена — контекст очищается. Модель всегда работает "налегке", видя только то, что нужно прямо сейчас.

---

## 5. RAG против Промпта: 10 000 страниц боли
**Интрига:** У нас есть база знаний размером с "Войну и Мир". Как заставить агента её знать?

**Вердикт:** **Единый Knowledge Skill + Поисковый Тул.**

**Почему именно так:**
Никогда не дробите базу знаний на 1000 мелких скиллов.
Сделайте один скилл "Библиотекарь". У него есть один мощный инструмент `search_knowledge_base`.
Найденная информация подается в диалог как *результат работы инструмента* (Tool Message), а не как часть системной инструкции. Это позволяет работать с бесконечными объемами данных, извлекая (Retrieve) только 3-5 нужных абзацев.

---

## 6. Бессмертная Память: Проблема "Дня Сурка"
**Интрига:** Диалог длится вечно. Контекстное окно переполняется. Как не забыть, что было в начале, но не хранить мусор?

**Вердикт:** **Суммаризация через графовый узел.**

**Почему именно так:**
Мы не можем просто отрезать начало (потеряем суть). Мы не можем хранить всё (дорого).
Решение: Специальный узел в графе (`summarize_conversation`) следит за длиной истории. Когда она превышает порог (N сообщений), он запускает LLM с задачей "Сожми этот текст".
Результат (`summary`) сохраняется отдельно и всегда добавляется к промпту, а старые сообщения физически удаляются (`RemoveMessage`). Агент помнит *смысл*, но забывает *слова*.
