---
name: technical-stats
description: Описывает техническую статистику сети и работу с ней — SQLite-база ai_data/network_stats.db, таблица hour_stats, read-only SQL. Использовать при запросах пользователя о статистике сети, KPI, метриках, отчётах по сотам (cellname), трафике, качестве, дропах, доступности.
allowed-tools: query_stats_db, execute_analysis_script, list_experiment_artifacts
---

# Техническая статистика сети

## Назначение

В проекте хранится **почасовая техническая статистика сети** (3G) в локальной SQLite-базе. Данные используются для анализа нагрузки, качества и KPI по сотам (cellname) и датам/часам. Доступ — **только чтение** (SELECT).

## Расположение и доступ

| Что | Где |
|-----|-----|
| База | `ai_data/network_stats.db` (от корня проекта) |
| Таблица | `hour_stats` — почасовая статистика по сотам |
| Инструмент агента | `query_stats_db(sql, max_rows=500, save_to_file=False)` — только SELECT. По умолчанию возвращает таблицу в ответе; при `save_to_file=True` сохраняет результат в `ai_data/query_<id>.tsv` и возвращает путь и сводку (строки, колонки), не загружая полный дамп в контекст |
| Модуль | `tools/stats_db.run_stats_query()` |

Ограничения: разрешены **только SELECT**-запросы; результат ограничен `max_rows` (по умолчанию 500).

## Схема таблицы `hour_stats`

**Идентификация:** по `dt` (дата-время) и `cellname` (код соты).

| Колонка | Тип | Описание |
|---------|-----|----------|
| `id` | INTEGER | PRIMARY KEY AUTOINCREMENT |
| `dt` | TEXT | Дата-время (YYYY-MM-DD HH:MM:SS) |
| `cellname` | INTEGER | Код соты |
| `cs_traffic` | REAL | Трафик CS |
| `ps_traffic` | REAL | Трафик PS |
| `cell_availability` | REAL | Доступность соты |
| `cssr_amr` | REAL | CSSR AMR |
| `voice_dcr` | REAL | Voice DCR (дропы голоса) |
| `rrc_cssr` | REAL | RRC CSSR |
| `rrc_dcr` | REAL | RRC DCR (дропы RRC) |
| `packet_ssr` | REAL | Packet SSR |
| `hsdpa_sr` | REAL | HSDPA success rate |
| `rab_ps_dcr_user` | REAL | RAB PS DCR (user) |
| `hsdpa_end_usr_thrp` | REAL | HSDPA throughput |
| `sho_factor` | REAL | SHO factor |
| `sho_sr` | REAL | SHO success rate |
| `rtwp` | REAL | RTWP |
| `cs_att` | REAL | CS попытки |
| `ps_att` | REAL | PS попытки |
| `branch` | INTEGER | Ветка |
| `active_user` | REAL | Активные пользователи |
| `code_block` | REAL | Code block |

## Принципы работы

1. **Только чтение** — INSERT/UPDATE/DELETE через `query_stats_db` запрещены; агент не должен пытаться менять данные.
2. **Формулировка запросов** — писать валидный SQL (SELECT ... FROM hour_stats [WHERE ...] [GROUP BY ...] [ORDER BY ...] [LIMIT ...]). Для больших выборок учитывать `max_rows` или явно задавать LIMIT. Для объёмных результатов использовать `save_to_file=True`, чтобы не раздувать контекст — данные сохранятся в файл, в ответ придёт путь и сводка.
3. **Агрегаты и фильтры** — для отчётов по периодам использовать `GROUP BY date(dt)` или диапазон по `dt` в WHERE; по сотам — `GROUP BY cellname` или фильтр по `cellname`.
4. **Интерпретация** — при ответах пользователю переводить результат в понятный текст/выводы; при необходимости округлять числа и указывать единицы.

## Типовые сценарии

- Сводка по датам: `SELECT date(dt) AS d, SUM(cs_traffic), SUM(ps_traffic), AVG(voice_dcr), AVG(rrc_dcr) FROM hour_stats GROUP BY d ORDER BY d`
- Топ сот по трафику: `SELECT cellname, SUM(cs_traffic) AS t_cs, SUM(ps_traffic) AS t_ps FROM hour_stats WHERE dt BETWEEN '...' AND '...' GROUP BY cellname ORDER BY (t_cs + t_ps) DESC LIMIT 20`
- Качество: фильтровать по `voice_dcr`, `rrc_dcr`, `cell_availability`, `cssr_amr`
- Трафик и активность: `cs_traffic`, `ps_traffic`, `cs_att`, `ps_att`, `active_user`

## RCA низкого трафика (методология)

При анализе «почему у соты низкий трафик» используй единую методологию.

### Стандартные KPI для RCA

| Группа | Колонки | Назначение |
|--------|---------|------------|
| Трафик/спрос | `cs_traffic`, `ps_traffic`, `cs_att`, `ps_att`, `active_user` | Объём и активность |
| Качество | `voice_dcr`, `rrc_dcr`, `cell_availability`, `cssr_amr`, `packet_ssr`, `hsdpa_sr` | Дропы, доступность, успешность |
| Нагрузка/ёмкость | `rtwp`, `hsdpa_end_usr_thrp`, `rab_ps_dcr_user` | Помехи, throughput |

### Интегральные оценки качества SQI1 и SQI2

Индикаторы из таблицы `hour_stats` разнесены по двум интегральным оценкам качества:

- **SQI1 (голос)** — интегральная оценка качества голосовых сервисов (CS/voice). Используй при вопросах о голосе, дропах звонков, доступности голоса.
- **SQI2 (данные)** — интегральная оценка качества пакетных данных (PS/data). Используй при вопросах о мобильном интернете, дропах данных, скорости HSDPA.

Расчёт числовых значений SQI1/SQI2 в коде не реализован; скилл задаёт только методологию разнесения KPI и интерпретации.

#### Индикаторы SQI1 (голос)

При агрегации показатель нормаируется на голосовой трафик (cs_traffic)

| Колонка | Описание |
|---------|----------|
| `cssr_amr` | CSSR AMR — успешность установки голосового вызова |
| `voice_dcr` | Voice DCR — дропы голосовых вызовов |

#### Индикаторы SQI2 (данные)

| Колонка | Описание |
|---------|----------|
| `ps_traffic` | Трафик PS (пакетный) |
| `rrc_cssr`, `rrc_dcr` | RRC — установка и дропы соединения по данным |
| `packet_ssr` | Packet SSR — успешность пакетных сессий |
| `hsdpa_sr` | HSDPA success rate |
| `rab_ps_dcr_user` | RAB PS DCR (дропы пакетных каналов) |
| `hsdpa_end_usr_thrp` | HSDPA throughput |
| `ps_att` | PS попытки (данные) |

#### Общие индикаторы

Учитываются при интерпретации и SQI1, и SQI2 (общие условия сети):

| Колонка | Описание |
|---------|----------|
| `cell_availability` | Доступность соты |
| `rtwp` | Уровень помех (влияет на голос и данные) |
| `active_user` | Активные пользователи |

Служебные/группировочные поля `branch`, `code_block` не входят в SQI; используются для фильтрации и разрезов (например, по веткам сети).

**Использование:** при вопросах про голосовые проблемы опирайся на KPI из группы SQI1 и общих; при вопросах про мобильный интернет/данные — на KPI из группы SQI2 и общих.

### Окна времени

- **baseline** — исторический период (например, от (max_date − 90 дней) до (max_date − 15 дней)): «норма» для соты.
- **recent** — последние N дней (например, 14): текущее состояние.

Сравнивай медианы (или средние) по `baseline` и `recent` для каждой соты.

### Классификация статуса соты

- **всегда низкий** — baseline уже низкий (например, ниже 10% перцентиля по трафику), recent примерно такой же; причина — изначально низкий спрос или малая зона.
- **стал низкий** — baseline в норме, recent заметно ниже (например, падение >30%); искать причину просадки.
- **аномалия / недостаточно данных** — мало точек, пропуски по датам или противоречивые метрики; в отчёте указывать «требует ручной проверки».

### Порядок проверки причин (RCA)

Проверяй гипотезы в фиксированном порядке и подкрепляй цифрами:

1. **Доступность** — нет ли провалов по датам, нулевой трафик при нулевых попытках (техсбой). Использовать `cell_availability`, `cs_att`, `ps_att`.
2. **Качество** — рост `voice_dcr`, `rrc_dcr`, падение `cssr_amr`, `cell_availability` в recent vs baseline.
3. **Спрос** — падение `cs_att`, `ps_att`, `active_user` при сохранном качестве (смещение трафика, отток абонентов).
4. **Нагрузка** — аномалии `rtwp`, `hsdpa_end_usr_thrp`, `rab_ps_dcr_user` (перегрузка или недогрузка после изменений).
5. **Сезонность/внешние факторы** — сравнение с тем же периодом год назад или с соседними сотами.

### Confidence (уверенность в причине)

Для каждой названной причины указывай **confidence** от 0 до 1:

- **0.8–1.0** — причина явно подтверждена метриками (например, рост voice_dcr на 20% при падении трафика).
- **0.5–0.8** — вероятная причина, есть подтверждающие KPI, но возможны иные факторы.
- **0.2–0.5** — гипотеза, данных недостаточно для однозначного вывода.
- **0–0.2** — спекуляция, без численного подтверждения не формулировать как вывод.

Без численного подтверждения вывод о причине делать запрещено.

## Кодовый контур (аналитические скрипты)

Для сложных расчётов и графиков используй генерацию кода и запуск через `execute_analysis_script(scenario_id, script_content, timeout_sec)`.

1. **GENERATE_SCRIPT** — сформируй Python-скрипт, который:
   - читает данные из БД по переменной окружения `DB_PATH` (sqlite3), таблица **hour_stats**;
   - пишет результаты только в `os.environ.get("OUTPUT_DIR", ".")`: таблицы в `results/`, графики в `plots/`;
   - использует только разрешённые библиотеки: pandas, numpy, matplotlib, seaborn, sqlite3, pathlib, os, json.
2. **RUN** — вызови `execute_analysis_script`. При успехе в ответе будут `log_path` и `result_paths`.
3. **VALIDATE** — проверь артефакты через `list_experiment_artifacts(scenario_id)`.
4. **DEBUG_LOOP** — при ошибке (success: False) по полю `error` (traceback) исправь скрипт и вызови `execute_analysis_script` снова. Не более 2–3 попыток; при повторяющейся ошибке зафиксируй в отчёте и перейди дальше.

Сценарий хранится в `ai_experiments/<scenario_id>/` (analysis.py, run.log, results/, plots/).

## Сценарий «низкий трафик БС» (end-to-end)

Выполняй по шагам; каждый шаг завершай STEP_RESULT с цифрами и confidence.

1. **Диапазон дат** — определи max_date по БД (из `hour_stats`), задай baseline (например max_date−90 … max_date−15) и recent (max_date−14 … max_date).
2. **Отбор сот с минимальным трафиком** — агрегация по cellname за recent, трафик = cs_traffic + ps_traffic. Топ-N с наименьшей медианой/суммой. Пример SQL:
   `SELECT cellname, SUM(cs_traffic) AS t_cs, SUM(ps_traffic) AS t_ps FROM hour_stats WHERE dt BETWEEN ? AND ? GROUP BY cellname ORDER BY (t_cs + t_ps) ASC LIMIT 20`
3. **Сравнение baseline vs recent** — по каждой отобранной соте посчитать медианы (или средние) за baseline и за recent по трафику и по KPI (voice_dcr, rrc_dcr, cell_availability, cs_att, ps_att, active_user). Классифицировать: «всегда низкий» / «стал низкий» / «аномалия».
4. **RCA** — для «стал низкий» проверить причины по порядку (доступность → качество → спрос → нагрузка → сезонность), каждую подкреплять метриками и присвоить confidence.
5. **Таблицы и графики** — для проблемных сот сформировать: таблицу метрик (baseline vs recent), 2–4 графика динамики (трафик, ключевые KPI по датам). Использовать `execute_analysis_script`: скрипт читает из DB_PATH (таблица hour_stats), пишет в OUTPUT_DIR/results/ и OUTPUT_DIR/plots/.
6. **FINAL_REPORT** — по шаблону (см. ниже): summary, список сот, RCA с confidence, рекомендации, пути к артефактам.

## Шаблон FINAL_REPORT

Итоговый отчёт по анализу низкого трафика оформляй в таком виде и сохраняй в `ai_experiments/<scenario_id>/report.md`.

```markdown
# FINAL_REPORT: Низкий трафик БС

## Executive summary
Кратко: сколько сот в выборке, сколько «всегда низкий» / «стал низкий», главная причина по сети (1–2 предложения).

## Топ проблемных сот
| cellname | Статус | Трафик recent | Трафик baseline | Изменение % |
|----------|--------|---------------|-----------------|-------------|
| …        | …      | …             | …               | …           |

## RCA по сотам
Для каждой проблемной соты (кратко):
- **cellname**: код
- **Вероятная причина**: текст
- **Confidence**: 0–1
- **Подтверждающие KPI**: метрики и значения
- **Рекомендации**: что проверить/сделать

## Рекомендации (приоритет)
1. …
2. …

## Артефакты
- Таблицы: пути к results/*.csv
- Графики: пути к plots/*.png
- Лог запуска: ai_experiments/<scenario_id>/run.log
```

## Генерация и загрузка данных

- **Тестовые данные** для таблицы `network_stats` создаются скриптом `tools/fake_network_stats.py` (команды `create-schema`, `generate`).
- **Основная рабочая таблица** — `hour_stats`; загружается из xlsx через `tools/load_hour_stats.py` (см. quickstart). БД при запросах агента считается уже существующей.
